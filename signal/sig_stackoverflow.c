// refer to: https://stackoverflow.com/questions/231912/what-is-the-difference-between-sigaction-and-signal

#include <errno.h>  // errno
#include <signal.h> // sigaction()
#include <stdio.h>  // printf()
#include <string.h> // strerror()
#include <stdlib.h> // exit()

// Format: const char *, unsigned int, const char *
#define LOG_LOCATION __FILE__, __LINE__, __func__ 
#define LOG_FORMAT_STR "file: %s, line: %u, func: %s: "

/// @brief      Callback function to handle termination signals, such as 
///             Ctrl + C
/// @param[in]  signal  Signal number of the signal being handled by this 
///             callback function
/// @return     None
static void termination_handler(const int signal)
{
    switch (signal)
    {
    case SIGINT:
        printf("\nSIGINT (%i) (Ctrl + C) signal caught.\n", signal);
        break;
    case SIGTERM:
        printf("\nSIGTERM (%i) (default `kill` or `killall`) signal caught.\n", 
            signal);
        break;
    case SIGHUP:
        printf("\nSIGHUP (%i) (\"hang-up\") signal caught.\n", signal);
        break;
    case SIGUSR1:
        printf("\nSIGUSR1 (%i) signal caught.\n", signal);
        break;
    case SIGUSR2:
        printf("\nSIGUSR2 (%i) signal caught.\n", signal);
        break;
    default:
        printf("\nUnk signal (%i) caught.\n", signal);
        break;
    }

    // DO PROGRAM CLEANUP HERE, such as freeing memory, closing files, etc.

    // exit(signal);
}

/// @brief      Set a new signal handler action for a given signal
/// @details    Only update the signals with our custom handler if they are NOT
///     set to "signal ignore" (`SIG_IGN`), which means they are currently
///     intentionally ignored. GCC recommends this "because non-job-control
///     shells often ignore certain signals when starting children, and it is
///     important for children to respect this." See
///     https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling
///     and
///     https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html.
///     Note that termination signals can be found here:
///     https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals
/// @param[in]  signal  Signal to set to this action
/// @param[in]  action  Pointer to sigaction struct, including the callback 
///     function inside it, to attach to this signal
/// @return     None
static inline void set_sigaction(int signal, const struct sigaction *action)
{
    struct sigaction old_action;

    // check current signal handler action to see if it's set to SIGNAL IGNORE
    sigaction(signal, NULL, &old_action);
    if (old_action.sa_handler != SIG_IGN)
    {
        // set new signal handler action to what we want
        int ret_code = sigaction(signal, action, NULL);
        if (ret_code == -1)
        {
            printf(LOG_FORMAT_STR "sigaction failed when setting signal to "
                   "%i; errno = %i: %s\n", 
                   LOG_LOCATION, signal, errno, strerror(errno));
        }
    }
}

int main(int argc, char *argv[])
{
    //...

    // Register callbacks to handle kill signals; prefer the Linux function
    // `sigaction()` over the C function `signal()`: "It is better to use
    // sigaction if it is available since the results are much more reliable."
    // Source:
    // https://www.gnu.org/software/libc/manual/html_node/Basic-Signal-Handling.html#Basic-Signal-Handling
    // and
    // https://stackoverflow.com/questions/231912/what-is-the-difference-between-sigaction-and-signal/232711#232711.
    // See here for official gcc `sigaction()` demo, which this code is modeled
    // after:
    // https://www.gnu.org/software/libc/manual/html_node/Sigaction-Function-Example.html

    // Set up the structure to specify the new action, per GCC's demo.
    struct sigaction new_action;
    new_action.sa_handler = termination_handler; // set callback function
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = 0;

    // SIGINT: ie: Ctrl + C kill signal
    set_sigaction(SIGINT, &new_action);
    // SIGTERM: termination signal--the default generated by `kill` and
    // `killall`
    set_sigaction(SIGTERM, &new_action);
    // SIGHUP: "hang-up" signal due to lost connection
    set_sigaction(SIGHUP, &new_action);
    // SIGUSR1: custom user signal 1
    set_sigaction(SIGUSR1, &new_action);
    // SIGUSR2: custom user signal 2
    set_sigaction(SIGUSR2, &new_action);

    while(1);

    //...
    return 0;
}

